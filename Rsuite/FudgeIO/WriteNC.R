# Aparna Radhakrishnan 08/04/2014
WriteNC <-  function(filename,data.array,var.name,
                     dim.list,
                     prec='double', missval=1.e20,
                     units,lname=var.name,cfname=var.name, 
                     bounds=FALSE, var.data=NA, 
                     writelist=FALSE, modulo=NA, 
                     verbose=FALSE) {
  #'Creates file filename (netCDF type) with the variable  var.name along with the 
  #'coordinate variables in the netCDF file, CF standard name, long names.
  #'
  #'@param filename: The name under which the data will be written
  #'@param prec: The precision of the variable being written to file. Defaults
  #'to 'double'
  #'@param missval: The value used to indicate missing values in the dataset
  #'when writing to file. Defaults to the CF-compliant 1.0e20
  #' -----Parameters related to the NetCDF variable-----
  #'@param data.array: The array containing the values of the variable to 
  #'be written to file. 
  #'@param var.name: The short name of the NetCDF variable being written. In the
  #'current FUDGE driver, picked up from the input var list.
  #'@param units: The units of the NetCDF variable. In the current FUDGE driver, 
  #'obtained by CFChecker
  #'@param lname: The long name of the NetCDF variable being written. In the current 
  #'FUDGE driver, generated by CF.R
  #'@param cfname: The CF-standard-compliant name of the variable being written.
  #'Currently obtained from CF.R, and defaults to var.name.
  #'@param modulo: If writing a climatology series, controls whether or not
  #'to write a modulo attribute showing the frequency over which the climatology
  #'series repeats.
  #'@param writelist: Is a list of variables being calculated and written to file
  #'(such as is the case with some of the standalone section 8 tools?) Defaults to 
  #'FALSE (only one variable written)
  #' ------Parameters related to the dimensions of the new NetCDF file----
  #'Note: at present, all time-related coordinates are obtained from the 
  #'time windowing mask file specified as the future predictor, and all 
  #'space-related coordinates are obtained from the spatial mask specified
  #'for the region.
  #'@param dim.list: A list of netCDF dimensions cloned from input files, 
  #'in something close to (x,y,...t) order. Bounds is *not* included
  #'since it has no relevance for the calculations in the main FUDGE
  #'code; the list of dimensions (and their names) is also used
  #'to clone attributes from the original NetCDf files for the dimsensions, 
  #'such as pressure. The list is also used to determine the dimensionality
  #'of the data to be written to file, if one or more degnerate dimensions
  #'were removed during reading in or manipulating the data. 
  #'@param var.data: A list of variables not calculated by the FUDGE code, 
  #'but carried over from the input function ReadNC as a whole. Used to write
  #'those variables (such as i and j offsets) to the output file for metadata
  #'purposes.
  #' ------Parameters related to status posting----
  #'@param verbose: Whether or not to write extended status messages for the 
  #'write process. Defaults to FALSE (no messages)

    
    FUDGEROOT = Sys.getenv(c("FUDGEROOT"))
    
    #' If CFNAME undefined in the call, pull information from CF.R. Use default otherwise. 
    #' #...you know what? Just stop passing in CFname for the calculated stats
    #print(cfname)
    if(length(cfname)==1){
      if(cfname == var.name){
        cflist <- GetCFName(var.name)
        if(is.list(cflist)){     ###CEW: Changed because was throwing a warning when cflist != "none"
          cfname <- cflist$cfname
          lname <- cflist$cflongname
          #print(paste("cfname:",cfname,sep=''))
        }else{
          print("CF.R does not contain this variable. Using default values")
        }
      }
    }
    
    #Define variable list and populate it
    var.dat <- list()
    
    #Changed 3-10 to support writing ensemble dimensions
    true.dim <- unlist((lapply(dim.list, "[[", "len")))
    
    if(!writelist){
      if(prod(true.dim)==prod(dim(data.array))){
        #If the only difference between the dims stored from the input files
        #and the dimensions of the data array are degenerate dimensions
        dim(data.array) <- true.dim
      }else{
        message(paste("Warning in WriteNC: the data in data.array has dimensions of", 
                      paste(dim(data.array), collapse=" "), 
                      "but the dimensions provided for writing are of the form", 
                      paste(true.dim, collapse=" "), "; all data may not be written to file."))
      }
      var.dat[[var.name]] <- ncvar_def(var.name,units=units,dim.list,missval=missval,longname=lname,prec=prec)#x,y,t1
    }else{ #If data.array *is* a list, assume that it contains several entries with names
      #This is going to have a neat effect on the variable name - add it only if you are 
      for (loop in 1:length(data.array)){
        if(prod(true.dim)==prod(dim(data.array[[loop]]))){
          #If the only difference between the dims stored from the input files
          #and the dimensions of the data array are degenerate dimensions
          dim(data.array[[loop]]) <- true.dim
        }else{
          message(paste("Warning in WriteNC: the data in data.array of", loop, "has dimensions of", 
                        paste(dim(data.array), collapse=" "), 
                        "but the dimensions provided for writing are of the form", 
                        paste(true.dim, collapse=" "), "; all data may not be written to file."))
        }
        if(verbose) { message(paste("defining var", var.name[[loop]])) }
        var.dat[[var.name[loop]]] <- ncvar_def(var.name[loop],
                                         units=units[loop],
                                         dim.list,
                                         missval=missval,
                                         longname=lname[loop],
                                         prec=prec)#x,y,t1
      }
    }
       
    #1-5 alternate structure
    bnds <- ncdim_def(name="bnds", longname = 'bnds' , units='', vals=seq(1:2), create_dimvar=TRUE) #'bounds', FALSE
    
    for (v in 1:length(var.data)){
      var <- names(var.data)[v]
      if(verbose) { message(paste("defining var", var)) }
      var.dim <- unlist(strsplit(attr(var.data[[v]], "dimids"), ","))
      var.dimlist <- list()
      if(var.dim[1]=='NA'){
        var.dimlist <- NULL
      }else{
        for(d in 1:length(var.dim)){
          #Okay...there's CLEARLY something in here that's not getting set with bnds
          #Investigating this on 4-15
          #4-15: Normally, no dimvar is created; if you set the longname att, that is not the case. 
          #Implies more standardization in input files? Maaaybe.
          #print(var.dim[[d]]) #Blame R's need to return all functions as elements of a list.
          var.dimlist[[d]] <- switch(as.character(var.dim[d]), 
                                     "bnds"=bnds, 
                                     dim.list[[as.character(var.dim[d])]])
        }
      }
      var.dat[[var]] <- ncvar_def(var, #var.data[[v]], #Don't forget to add the data in somewhere 
                                  units=attr(var.data[[var]], "units"), #Add check for adding units back in if not present
                                  #units="",
                                  dim=var.dimlist, 
                                  #missval=as.numeric(attr(var.data[[var]], "missval") ), #Add check for this as well. 
                                  longname = attr(var.data[[var]], "longname"), 
                                  prec = attr(var.data[[var]], "prec") #This one gave me hives last time.
                                  )
    }
    #save('var.dat', file="/home/cew/Code/testing/ncvars.out")
    if(verbose) { message("creating nc objects") }
    #save(list=("var.dat"), file="/home/cew/Code/odd_var_out")
    #stop("investigate your output")
    nc.obj <- nc_create(filename, var.dat, verbose=FALSE)
    if(verbose) { message("placing nc vars") }
    if(!writelist){
      nc.obj <- nc_open(filename, write=TRUE)
      ncvar_put(nc.obj, var.dat[[var.name]], data.array)
    }else{
      for (loop in 1:length(data.array)){
        #nc.obj <- nc_open(filename, write=TRUE)
        loop.varname <- names(data.array)[loop]
        if(verbose) { message(paste("populating", loop.varname)) }
        ncvar_put(nc=nc.obj, 
                            varid=var.dat[[loop.varname]], 
                            vals=data.array[[loop.varname]], verbose=FALSE)
      }
    }
    for (v in 1:length(var.data)){
      loop.var <- names(var.data)[[v]]
      if(verbose) { message(paste("adding", loop.var, "and attributes")) }      
      ncvar_put(nc.obj, var.dat[[loop.var]], var.data[[loop.var]])
      all.att.list <- attributes(var.data[[loop.var]])
      #Note: failure to include missval as one of the attributes that  doesn't get set 
      #will result in giving all vars a missing value of 1e30. 
      all.att.list <- all.att.list[!(names(all.att.list)%in% c("units", "longname", "prec", "dim", "dimids", "missval"))]
      if(length(all.att.list) > 0){
        for (at in 1:length(all.att.list)){
          ncatt_put(nc.obj, loop.var,  names(all.att.list)[[at]], all.att.list[[at]])
        }
      }
    }
    if(verbose) { print("cloning attributes") }
    dim.exclude <- c("bnds")    #List of dimensions not to copy atts from
    dim.index <- !(names(dim.list)%in%dim.exclude)
    dim.names <- dim.list[[dim.index]]
    for (i in 1:length(dim.names)){
      dim.name <- dim.names[i]
      orig.file <- attr(dim.list[[dim.name]], "filename")
      if(!is.null(orig.file)){
        #dim.name <- names(dim.list)[i] #commented this out; prev.indexed by i
        #This may not work if you name the arguments present. Check on that?
        nc.copy.atts(nc_open(orig.file), dim.name, nc.obj, dim.name, c("_FillValue", "FillValue", "_missval"))
      }else{
        if(verbose) { print("null dim; skipping to next") }
      }
    }
    
    #Link axes to the dimensions
    ncatt_put(nc.obj,"time","axis",'T')
    ncatt_put(nc.obj,"lat","axis",'Y')
    ncatt_put(nc.obj,"lon","axis",'X')

      #Link bounds variables to the corresponding dims
      ncatt_put(nc.obj, "lat", 'bounds', 'lat_bnds')
      ncatt_put(nc.obj, "lon", 'bounds', 'lon_bnds')
      ncatt_put(nc.obj, "time", 'bounds', 'time_bnds')
    #And establish long names in the code
    ncatt_put(nc.obj,"time","standard_name","time")
    ncatt_put(nc.obj, "time", "long_name", "time")
    ncatt_put(nc.obj,"lat","standard_name","latitude")
    ncatt_put(nc.obj,"lat","long_name","latitude")
    ncatt_put(nc.obj,"lon","standard_name","longitude")
    ncatt_put(nc.obj,"lon","long_name","longitude")
    
    ##CEW: figure out how to add these in once rest are tested
#    ncatt_put(nc.obj,var.dat[[var.name]],"units",units)
    #The cfname attribute behavior needs to be checked more
    if(length(cfname)==1 && cfname!='none'){
      ncatt_put(nc.obj,var.dat[[var.name]],"standard_name",cfname)
    }
    #Climatology
    if(!is.na(modulo)){
      ncatt_put(nc.obj, "time", 'modulo', "")
    }
    ########### write grid coordinate bounds ####################
    
    #############################################################  
    nc_close(nc.obj)
    return(filename)
}
